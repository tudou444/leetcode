//归并排序 时间O（nlogn）空间（n）
class Solution {
    vector<int> temp;
    void mergeSort(vector<int>& nums, int left, int right){
        if(left >= right) return;
        int mid = left + ((right-left))>>2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid+1, right);
        int p1 = left, p2 = mid + 1;
        int cnt = 0; //用于给临时数组计数
        while(p1 <= mid && p2 <= right){
            temp[cnt++] = (nums[p1] <= nums[p2]) ? nums[p1++] : nums[p2++];
        }
        while(p1 <= mid){
            temp[cnt++] = nums[p1++];
        }
        while(p2 <= right){
            temp[cnt++] = nums[p2++];
        }
        for(int i = 0; i < right-left+1; i++){
            nums[left + i] = temp[i];
        }
    }

public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        temp.resize(n, 0);
        mergeSort(nums, 0, n-1);
        return nums;
    }
};


//快速排序
class Solution {
    vector<int> partition(vector<int>& nums, int L, int R){
        int less = L - 1, more = R;
        while(L < more){
            if(nums[L] < nums[R]){
                swap(nums[L], nums[++less]);
                L++;
            }else if(nums[L] > nums[R]){
                swap(nums[L], nums[--more]);
            }else{
                L++;
            }
        }
        swap(nums[R], nums[more]);
        return {less+1, more};
    }
    void quickSort(vector<int>& nums, int L, int R){
        if(L < R){
            int i = rand() % (R - L + 1) + L; //在（L，R）上随机选取一个位置
            swap(nums[R], nums[i]);
            vector<int> pos = partition(nums, L, R);
            quickSort(nums, L, pos[0] - 1);
            quickSort(nums, pos[1] + 1, R);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        srand((unsigned)time(NULL));
        quickSort(nums, 0, n-1);
        return nums;
    }
};
